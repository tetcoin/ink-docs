[{"title":"Cargo.toml","type":0,"sectionRef":"#","url":"basics/cargo-toml","content":"TODO go through a typical Cargo.toml and explain what the dependencies mean","keywords":""},{"title":"Contract Template","type":0,"sectionRef":"#","url":"basics/contract-template","content":"Change into your working directory and run: Copy cargo contract new foobar This will create a new project folder named foobar. Copy cd foobar/ In the lib.rs file you find initial scaffolded code, which you can use as a starting point. Quickly check that it compiles and the trivial tests pass with: Copy cargo +nightly test Also check that you can build the Wasm file by running: Copy cargo +nightly contract build If everything looks good, then we are ready to start programming!","keywords":""},{"title":"Cross-Contract Calling","type":0,"sectionRef":"#","url":"basics/cross-contract-calling","content":"","keywords":""},{"title":"How it Works","type":1,"pageTitle":"Cross-Contract Calling","url":"basics/cross-contract-calling#how-it-works","content":"In order to deploy the delegator smart contract we first have to manually put the code of the other contract, receive its code hash from the signalled event and put their code hash into our calling smart contract. The calling contract looks like this: Copy use ink_storage::Lazy; use other_contract::OtherContract; //--snip-- #[ink(storage)] struct MyContract { /// The other contract. other_contract: Lazy<OtherContract>, } impl MyContract { /// Instantiate `MyContract with the given /// sub-contract codes and some initial value. #[ink(constructor)] pub fn new( other_contract_code_hash: Hash, ) -> Self { let other_contract = OtherContract::new(1337) .endowment(total_balance / 4) .code_hash(other_contract_code_hash) .instantiate() .expect(\"failed at instantiating the `OtherContract` contract\"); Self { other_contract } } /// Calls the other contract. #[ink(message)] pub fn call_other_contract(&self) -> i32 { self.other_contract.get_value() } } //--snip-- It's Cargo.toml contains Copy other_contract = { path = \"other_contract\", default-features = false, features = [\"ink-as-dependency\"] } The other_contract/Cargo.toml contains this: Copy [features] ink-as-dependency = [] Tells the pro! code generator to always or nevercompile the smart contract as if it was used as a dependency of another pro! smart contract. The other_contract/lib.rs: Copy #[ink::contract] pub mod other_contract { /// Storage for the other contract. #[ink(storage)] pub struct OtherContract { value: i32, } impl OtherContract { /// Initializes the contract. #[ink(constructor)] pub fn new(value: i32) -> Self { Self { value } } /// Returns the current state. #[ink(message)] pub fn get_value(&self) -> i32 { self.value } } } "},{"title":"Contract Testing","type":0,"sectionRef":"#","url":"basics/contract-testing","content":"","keywords":""},{"title":"Unit Tests","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#unit-tests","content":"Testing contracts off-chain is done by cargo test and users can simply use the standard routines of creating unit test modules within the pro! project: Copy #[cfg(test)] mod tests { use super::*; #[test] fn my_test() { ... } } Test instances of contracts can be created with something like: Copy let contract = MyContract::my_constructor(a, b); Messages can simply be called on the returned instance as if MyContract::my_constructor returns aSelf instance. See the flipper example. "},{"title":"Off-chain Testing","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#off-chain-testing","content":"pro! smart contracts can compile in several different modes. There are two main compilation models using either on-chain mode: no_std + WebAssembly as targetoff-chain mode: std We generally use the on-chain mode for actual smart contract deployment whereas we use the off-chain mode for smart contract testing using the off-chain environment provided by the ink_env crate. The #[ink::test] proc. macro enables more elaborate off-chain testing. If you annotate a test with this attribute it will be executed in a simulated environment, similar to as it would be run on-chain. You then have fine-grained control over how a contract is called; for example you can influence the block advancement, the value transferred to it, by which account it is called, which storage it is run with, etc.. See the examples/erc20 contract on how to utilize those or the documentation for details. At the moment there are some known limitations to our off-chain environment and we are working on making it behave as close to the real chain environment as possible. Defines a unit test that makes use of pro!'s off-chain testing capabilities. If your unit test does not require the existence of an off-chain environment it is fine to not use this macro since it bears some overhead with the test. Note that this macro is not required to run unit tests that require pro!'s off-chain testing capabilities but merely improves code readability. "},{"title":"How do you find out if your test requires the off-chain environment?","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#how-do-you-find-out-if-your-test-requires-the-off-chain-environment","content":"Normally if the test recursively uses or invokes some contract methods that call a method defined in self.env() or Self::env(). An examples is the following: Copy let caller: AccountId = self.env().caller(); "},{"title":"Example","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#example","content":"Copy use ink_lang as ink; #[cfg(test)] mod tests { // Conventional unit test that works with assertions. #[ink::test] fn test1() { // test code comes here as usual } // Conventional unit test that returns some Result. // The test code can make use of operator-`?`. #[ink::test] fn test2() -> Result<(), ink_env::Error> { // test code that returns a Rust Result type } } "},{"title":"On-chain Testing","type":1,"pageTitle":"Contract Testing","url":"basics/contract-testing#on-chain-testing","content":"The easiest way to do on-chain testing is torun a local substrate node, deploy your contract there and interact with it. Copy use ink_lang as ink; #[ink::contract] mod greeter { #[ink(storage)] pub struct Greeter; impl Greeter { #[ink(constructor)] pub fn new() -> Self { let caller = Self::env().caller(); let message = format!(\"thanks for instantiation {:?}\", caller); ink_env::debug_println(&message); Greeter {} } #[ink(message, payable)] pub fn fund(&mut self) { let caller = self.env().caller(); let value = self.env().transferred_balance(); let message = format!(\"thanks for the funding of {:?} from {:?}\", value, caller); ink_env::debug_println(&message); } } } "},{"title":"Events","type":0,"sectionRef":"#","url":"basics/events","content":"","keywords":""},{"title":"Event Definition","type":1,"pageTitle":"Events","url":"basics/events#event-definition","content":"This is how an event definition looks: Copy #[ink(event)] pub struct Transferred { #[ink(topic)] from: Option<AccountId>, #[ink(topic)] to: Option<AccountId>, amount: Balance } Add the #[ink(topic)] attribute tag to each item in your event that you want to have indexed. A good rule of thumb is to ask yourself if somebody might want to search for this topic. For this reason the amount in the exemplary event above was not made indexable ‒ there will most probably be a lot of different events with differing amounts each. The signature of the event is by default one of the topics of the event, except if you annotate the event with #[ink(anonymous)]. See here for details on this attribute. "},{"title":"Emitting Events in a Constructor","type":1,"pageTitle":"Events","url":"basics/events#emitting-events-in-a-constructor","content":"In a constructor events are emitted via Self::env().emit_event(). See this example: Copy #[ink(constructor)] pub fn new(initial_value: Balance) -> Self { let caller = Self::env().caller(); let mut balances = HashMap::new(); balances.insert(caller, initial_supply); Self::env().emit_event(Transferred { from: None, to: Some(caller), amount: initial_supply }); Self { total_supply: initial_supply, balances } } "},{"title":"Emitting Events from Messages","type":1,"pageTitle":"Events","url":"basics/events#emitting-events-from-messages","content":"In a message events are emitted via self.env().emit_event(): Copy #[ink(message)] pub fn transfer(&mut self, to: AccountId, amount: Balance) -> Result { let from = self.env().caller(); // implementation hidden self.env().emit_event(Transferred { from: Some(from), to: Some(to), amount }); Ok(()) } "},{"title":"Environment Functions","type":0,"sectionRef":"#","url":"basics/environment-functions","content":"pro! exposes a number of handy environment functions. A full overview is found here. In an #[ink(constructor)] use Self::env() to access those, in an #[ink(message)] use self.env(). So e.g. Self::env().caller() or self.env().caller(). Some handy functions include: caller(): Returns the address of the caller of the executed contract. An example of how to utilize this particular call is found here.account_id(): Returns the account ID of the executed contract.balance(): Returns the balance of the executed contract.block_number(): Returns the current block number.random(): Returns a random hash seed.emit_event(…): Emits an event with the given event data.transfer(…): Transfers value from the contract to the destination account ID.hash_bytes(…): Conducts the crypto hash of the given input and stores the result in output.…and many more.","keywords":""},{"title":"Reading Values from Storage","type":0,"sectionRef":"#","url":"basics/reading-values","content":"","keywords":""},{"title":"Contract Functions","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#contract-functions","content":"As you can see in the contract template, all of your contract functions are part of your contract module. Copy impl MyContract { // Public and Private functions can go here } "},{"title":"Public and Private Functions","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#public-and-private-functions","content":"In Rust, you can make as many implementations as you want. As a stylistic choice, we recommend breaking up your implementation definitions for your private and public functions: Copy impl MyContract { /// Public function #[ink(message)] pub fn my_public_function(&self) { /* --snip-- */ } /// Private function fn my_private_function(&self) { /* --snip-- */ } /* --snip-- */ } You can also choose to split things up however is most clear for your project. Note that all public functions must use the #[ink(message)] attribute. "},{"title":"Storage Value API","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#storage-value-api","content":"Without going into so much detail, storage values are a part of the underlying pro! core layer. In the background, they use a more primitive cell type which holds an Option<T>. When we try to get the value from storage, we unwrap the value, which is why it panics if it is not initialized! Copy impl<T> Value<T> where T: scale::Codec, { /// Returns an immutable reference to the wrapped value. pub fn get(&self) -> &T { self.cell.get().unwrap() } /// Returns a mutable reference to the wrapped value. pub fn get_mut(&mut self) -> &mut T { self.cell.get_mut().unwrap() } /// Sets the wrapped value to the given value. pub fn set(&mut self, val: T) { self.cell.set(val); } } In that same file, you can find the other APIs exposed by storage values, however these three are the most commonly used. "},{"title":"Getting a Value","type":1,"pageTitle":"Reading Values from Storage","url":"basics/reading-values#getting-a-value","content":"We already showed you how to initialize a storage value. Getting the value is just as simple: Copy impl MyContract { #[ink(message)] pub fn my_getter(&self) -> u32 { self.number } } In Rust, if the last expression in a function does not have a semicolon, then it will be the return value. "},{"title":"Storing Values","type":0,"sectionRef":"#","url":"basics/storing-values","content":"","keywords":""},{"title":"Supported Types","type":1,"pageTitle":"Storing Values","url":"basics/storing-values#supported-types","content":"Contracts may store types that are encodable and decodable with Parity Codec which includes the most common types such as bool, u{8,16,32,64,128}, i{8,16,32,64,128}, String, tuples, and arrays. pro! provides smart contracts Substrate specific types like AccountId, Balance, and Hash as if they were primitive types. Also pro! provides storage types for more elaborate storage interactions through the storage module: Copy use ink_storage::collections::{Vec, HashMap, Stash, Bitvec}; Here is an example of how you would store an AccountId and Balance: Copy // We are importing the default pro! types use ink_lang as ink; #[ink::contract] mod MyContract { // Our struct will use those default pro! types #[ink(storage)] pub struct MyContract { // Store some AccountId my_account: AccountId, // Store some Balance my_balance: Balance, } /* --snip-- */ } You can find all the supported Substrate types in crates/storage/src/lib.rs. "},{"title":"Initializing Storage in Constructors","type":1,"pageTitle":"Storing Values","url":"basics/storing-values#initializing-storage-in-constructors","content":"Constructors are how values get initialized. Every pro! smart contract must have a constructor which is run once when a contract is created. pro! smart contracts can have multiple constructors: Copy use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { number: u32, } impl MyContract { /// Constructor that initializes the `u32` value to the given `init_value`. #[ink(constructor)] pub fn new(init_value: u32) -> Self { Self { number: init_value, } } /// Constructor that initializes the `u32` value to the `u32` default. #[ink(constructor)] pub fn default() -> Self { Self { number: Default::default(), } } /* --snip-- */ } } "},{"title":"Mutating Storage Values","type":0,"sectionRef":"#","url":"basics/mutating-values","content":"","keywords":""},{"title":"Mutable and Immutable Functions","type":1,"pageTitle":"Mutating Storage Values","url":"basics/mutating-values#mutable-and-immutable-functions","content":"You may have noticed that the function templates included self as the first parameter of the contract functions. It is through self that you gain access to all your contract functions and storage items. If you are simply reading from the contract storage, you only need to pass &self. But if you want to modify storage items, you will need to explicitly mark it as mutable, &mut self. Copy impl MyContract { #[ink(message)] pub fn my_getter(&self) -> u32 { self.my_number } #[ink(message)] pub fn my_setter(&mut self, new_value: u32) { self.my_number = new_value; } } "},{"title":"Lazy Storage Values","type":1,"pageTitle":"Mutating Storage Values","url":"basics/mutating-values#lazy-storage-values","content":"There is a Lazy type that can be used for pro! storage values that don't need to be loaded in some or most cases. Because they do not meet this criteria, many simple pro! examples do not require the use Lazy values. Since there is some overhead associated with Lazy values, they should only be used where required. Copy #[ink(storage)] pub struct MyContract { // Store some number my_number: ink_storage::Lazy<u32>, } impl MyContract { #[ink(constructor)] pub fn new(init_value: i32) -> Self { Self { my_number: Default::default(), } } #[ink(message)] pub fn my_setter(&mut self, new_value: u32) { ink_storage::Lazy::<u32>::set(&mut self.my_number, new_value); } #[ink(message)] pub fn my_adder(&mut self, add_value: u32) { let my_number = &mut self.my_number; let cur = ink_storage::Lazy::<u32>::get(my_number); ink_storage::Lazy::<u32>::set(my_number, cur + add_value); } } "},{"title":"Overview","type":0,"sectionRef":"#","url":"cargo-contract-cli","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Overview","url":"cargo-contract-cli#installation","content":"You can install it this way: Copy cargo install cargo-contract --vers 0.8.0 --force --locked Use the --force to ensure you are updated to the most recent cargo-contract version. "},{"title":"Usage","type":1,"pageTitle":"Overview","url":"cargo-contract-cli#usage","content":"In order to initialize a new pro! project you can use: Copy cargo contract new flipper This will create a folder flipper in your work directory. The folder contains a scaffold Cargo.toml and a lib.rs, which both contain the necessary building blocks for using pro!. The lib.rs contains our hello world contract ‒ the Flipper, which we explain in the next section. In order to build the contract just execute these commands in the flipper folder: Copy cargo contract build As a result you'll get the file target/flipper.contract. It's a JSON which bundles the contract's metadata and its Wasm blob. This file needs to be used when deploying the contract. You additionally get the individual target/flipper.wasm and target/metadata.json in the folder as well. "},{"title":"Call a Contract","type":0,"sectionRef":"#","url":"cargo-contract-cli/call","content":"TODO","keywords":""},{"title":"Deploy a Contract","type":0,"sectionRef":"#","url":"cargo-contract-cli/deploy","content":"TODO","keywords":""},{"title":"Trait Definitions","type":0,"sectionRef":"#","url":"basics/trait-definitions","content":"","keywords":""},{"title":"Example","type":1,"pageTitle":"Trait Definitions","url":"basics/trait-definitions#example","content":"Defined in the base_erc20.rs module. Copy use ink_lang as ink; #[ink::trait_definition] pub trait BaseErc20 { /// Creates a new ERC-20 contract and initializes it with the initial supply for the instantiator. #[ink(constructor)] fn new(initial_supply: Balance) -> Self; /// Returns the total supply. #[ink(message)] fn total_supply(&self) -> Balance; /// Transfers `amount` from caller to `to`. #[ink(message, payable)] fn transfer(&mut self, to: AccountId, amount: Balance); } An pro! smart contract definition can then implement this trait definition as follows: Copy use ink_lang as ink; #[ink::contract] mod erc20 { use base_erc20::BaseErc20; #[ink(storage)] pub struct Erc20 { total_supply: Balance, // more fields ... } impl BaseErc20 for Erc20 { #[ink(constructor)] fn new(initial_supply: Balance) -> Self { // implementation ... } #[ink(message)] fn total_supply(&self) -> Balance { // implementation ... } #[ink(message, payable)] fn transfer(&mut self, to: AccountId, amount: Balance) { // implementation ... } } } Calling the above Erc20 explicitely through its trait implementation can be done just as if it was normal Rust code: Copy // --- Instantiating the ERC-20 contract: // let mut erc20 = <Erc20 as BaseErc20>::new(1000); // --- Is just the same as: use base_erc20::BaseErc20; let mut erc20 = Erc20::new(1000); // --- Retrieving the total supply: // assert_eq!(<Erc20 as BaseErc20>::total_supply(&erc20), 1000); // --- Is just the same as: use base_erc20::BaseErc20; assert_eq!(erc20.total_supply(), 1000); There are still many limitations to pro! trait definitions and trait implementations. For example it is not possible to define associated constants or types or have default implemented methods. These limitations exist because of technical intricacies, however, please expect that many of those will be tackled in future pro! releases. Marks trait definitions to pro! as special pro! trait definitions. There are some restrictions that apply to pro! trait definitions that this macro checks. Also pro! trait definitions are required to have specialized structure so that the main #[ink::contract] macro can properly generate code for its implementations. Example: Definition# Copy use ink_lang as ink; type Balance = <ink_env::DefaultEnvironment as ink_env::Environment>::Balance; #[ink::trait_definition] pub trait Erc20 { /// Constructs a new ERC-20 compliant smart contract using the initial supply. #[ink(constructor)] fn new(initial_supply: Balance) -> Self; /// Returns the total supply of the ERC-20 smart contract. #[ink(message)] fn total_supply(&self) -> Balance; // etc. } Example: Implementation# Given the above trait definition you can implement it as shown below: Copy use ink_lang as ink; #[ink::contract] mod base_erc20 { /// We somehow cannot put the trait in the doc-test crate root due to bugs. #[ink_lang::trait_definition] pub trait Erc20 { Constructors a new ERC-20 compliant smart contract using the initial supply. #[ink(constructor)] fn new(initial_supply: Balance) -> Self; /// Returns the total supply of the ERC-20 smart contract. #[ink(message)] fn total_supply(&self) -> Balance; } #[ink(storage)] pub struct BaseErc20 { total_supply: Balance, // etc .. } impl Erc20 for BaseErc20 { #[ink(constructor)] fn new(initial_supply: Balance) -> Self { Self { total_supply: initial_supply } } /// Returns the total supply of the ERC-20 smart contract. #[ink(message)] fn total_supply(&self) -> Balance { self.total_supply } // etc .. } } "},{"title":"Instantiate a Contract","type":0,"sectionRef":"#","url":"cargo-contract-cli/instantiate","content":"TODO I am trying to deploy and instantiate a contract using a custom-built cargo-contract with the extrinsics feature. The 'deploy' and 'instantiate' commands require a \"secret key uri\" and \"secret key password\" that I don't know how to find for my canvas devnet. Can somebody help me understand what these are and how to obtain them? You probably just need to the key for some account with enough funds to deploy and instantiate the contract...I don't think the key is specific to the node in any way If you're running the Canvas node in dev mode, these are the accounts that are pre-funded https://github.com/paritytech/canvas-node/blob/master/node/src/chain_spec.rs#L76People typically use Alice...her information is here https://substrate.dev/docs/en/knowledgebase/integrate/subkey#well-known-keys I guess you'd just leave the password blank So the secret key URI will be bottom drive obey lake curtain smoke basket hold race lonely fit walk//Alice I think","keywords":""},{"title":"Custom Datastructures","type":0,"sectionRef":"#","url":"datastructures/custom-datastructure","content":"While the ink_storage crate provides tons of useful utilities and data structures to organize and manipulate the contract's storage contract authors are not limited by its capabilities. By implementing the core SpreadLayout and PackedLayout traits users are able to define their very own custom storage data structures with their own set of requirement and features that work along the ink_storage data structures as long as they fulfill the mere requirements stated by those two traits. In the future we plan on providing some more pro! workshops and tutorials guiding the approach to design and implement a custom storage data structure.","keywords":""},{"title":"Dynamic Storage Allocator","type":0,"sectionRef":"#","url":"datastructures/dynamic-allocation","content":"In the previous section we have seen how the default mode of operation is to spread information and how we can opt-in to pack information into single cells via ink_storage::Packed. However, what if we wanted to store a vector of a vector of i32 for example? Naturally a user would try to construct this as follows: Copy use ink_storage::Vec as StorageVec; #[ink(storage)] pub struct Matrix { values: StorageVec<StorageVec<i32>>, } However, this will fail compilation with an error indicating that StorageVec<T> requires for its T to be packed (T: PackedLayout) which StorageVec<T> itself does not since it always stores all of its elements into different cells. The same applies to many other storage data structures provided by ink_storage and is a trade-off the pro! team decided for the case of efficiency of the overall system. Instead what a user can do in order to get their vector-of-vector to be working is to make use of pro!'s dynamic storage allocator capabilities. For this the contract author has to first enable the feature via: Copy use ink_lang as ink; #[ink::contract(dynamic_storage_allocator = true)] mod matrix { // contract code ... } And then we can define our Matrix #[ink(storage)] as follows: Copy use ink_storage::{ Vec as StorageVec, Box as StorageBox, }; #[ink(storage)] pub struct Matrix { values: StorageVec<StorageBox<StorageVec<i32>>>, } With ink_storage::Box<T> we can use a T: SpreadLayout as if it was T: PackedLayout since the ink_storage::Box<T> itself suffices the requirements and can be put into a single contract storage cell. The whole concept works quite similar to how Rust's Box works: by an indirection - contract authors are therefore advised to make use of dynamic storage allocator capabilities only if other ways of dealing with ones problems are not applicable.","keywords":""},{"title":"Opt out of Storage","type":0,"sectionRef":"#","url":"datastructures/opting-out","content":"If you are in need of storing some temporary information across method and message boundaries pro! will have your back with the ink_storage::Memory abstraction. It allows you to simply opt-out of using the storage for the wrapped entity at all and thus is very similar to Solidity's very own memory annotation. An example below: Copy #[ink(storage)] pub struct OptedOut { a: i32, b: ink_storage::Lazy<i32>, c: ink_storage::Memory<i32>, } The the above example a and b are normal storage entities, however, c on the other hand side will never load from or store to contract storage and will always be reset to the default value of its i32 type for every contract call. It can be accessed from all pro! messages or methods via self.c, but will never manipulate the contract storage and thus acts wonderfully as some shared local information.","keywords":""},{"title":"Working with Datastructures","type":0,"sectionRef":"#","url":"datastructures/hashmap","content":"","keywords":""},{"title":"Storage HashMap API","type":1,"pageTitle":"Working with Datastructures","url":"datastructures/hashmap#storage-hashmap-api","content":"You can find the full HashMap API in the crate documentation part of pro!. Here are some of the most common functions you might use: Copy /// Inserts a key-value pair into the map. /// Returns the previous value associated with the same key if any. /// If the map did not have this key present, `None` is returned. pub fn insert(&mut self, key: K, new_value: V) -> Option<V> {/* --snip-- */} /// Removes the key/value pair from the map associated with the given key. /// /// - Returns the removed value if any. pub fn take<Q>(&mut self, key: &Q) -> Option<V> {/* --snip-- */} /// Returns a shared reference to the value corresponding to the key. /// /// The key may be any borrowed form of the map's key type, /// but `Hash` and `Eq` on the borrowed form must match those for the key type. pub fn get<Q>(&self, key: &Q) -> Option<&V> {/* --snip-- */} /// Returns a mutable reference to the value corresponding to the key. /// /// The key may be any borrowed form of the map's key type, /// but `Hash` and `Eq` on the borrowed form must match those for the key type. pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V> {/* --snip-- */} /// Returns `true` if there is an entry corresponding to the key in the map. pub fn contains_key<Q>(&self, key: &Q) -> bool {/* --snip-- */} /// Converts the OccupiedEntry into a mutable reference to the value in the entry /// with a lifetime bound to the map itself. pub fn into_mut(self) -> &'a mut V {/* --snip-- */} /// Gets the given key's corresponding entry in the map for in-place manipulation. pub fn entry(&mut self, key: K) -> Entry<K, V> {/* --snip-- */} "},{"title":"Initializing a HashMap","type":1,"pageTitle":"Working with Datastructures","url":"datastructures/hashmap#initializing-a-hashmap","content":"Not initializing storage before you use it is a common error that can break your smart contract. For each key in a storage value, the value needs to be set before you can use it. To do this, we will create a private function which handles when the value is set and when it is not, and make sure we never work with uninitialized storage. So given my_number_map, imagine we wanted the default value for any given key to be 0. We can build a function like this: Copy #![cfg_attr(not(feature = \"std\"), no_std)] use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { // Store a mapping from AccountIds to a u32 my_number_map: ink_storage::collections::HashMap<AccountId, u32>, } impl MyContract { /// Public function. /// Default constructor. #[ink(constructor)] pub fn default() -> Self { Self { my_number_map: Default::default(), } } /// Private function. /// Returns the number for an AccountId or 0 if it is not set. fn my_number_or_zero(&self, of: &AccountId) -> u32 { let balance = self.my_number_map.get(of).unwrap_or(&0); *balance } } } Here we see that after we get the value from my_number_map we call unwrap_or which will either unwrap the value stored in storage, or if there is no value, return some known value. Then, when building functions that interact with this HashMap, you need to always remember to call this function rather than getting the value directly from storage. Here is an example: Copy #![cfg_attr(not(feature = \"std\"), no_std)] use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { // Store a mapping from AccountIds to a u32 my_number_map: ink_storage::collections::HashMap<AccountId, u32>, } impl MyContract { // Get the value for a given AccountId #[ink(message)] pub fn get(&self, of: AccountId) -> u32 { self.my_number_or_zero(&of) } // Get the value for the calling AccountId #[ink(message)] pub fn get_my_number(&self) -> u32 { let caller = self.env().caller(); self.my_number_or_zero(&caller) } // Returns the number for an AccountId or 0 if it is not set. fn my_number_or_zero(&self, of: &AccountId) -> u32 { let value = self.my_number_map.get(of).unwrap_or(&0); *value } } } "},{"title":"Contract Caller","type":1,"pageTitle":"Working with Datastructures","url":"datastructures/hashmap#contract-caller","content":"As you might have noticed in the example above, we use a special function called self.env().caller(). This function is available throughout the contract logic and will always return to you the contract caller. NOTE: The contract caller is not the same as the origin caller. If a user triggers a contract which then calls a subsequent contract, the self.env().caller() in the second contract will be the address of the first contract, not the original user. self.env().caller() can be used a number of different ways. In the examples above, we are basically creating an \"access control\" layer which allows a user to modify their own value, but no one else. You can also do things like define a contract owner during contract deployment: Copy #![cfg_attr(not(feature = \"std\"), no_std)] use ink_lang as ink; #[ink::contract] mod mycontract { #[ink(storage)] pub struct MyContract { // Store a contract owner owner: AccountId, } impl MyContract { #[ink(constructor)] pub fn new(init_value: i32) -> Self { Self { owner: Self::env().caller(); } } /* --snip-- */ } } Then you can write permissioned functions which checks that the current caller is the owner of the contract. "},{"title":"Modifying a HashMap","type":1,"pageTitle":"Working with Datastructures","url":"datastructures/hashmap#modifying-a-hashmap","content":"Making changes to the value of a HashMap is just as sensitive as getting the value. If you try to modify some value before it has been initialized, your contract will panic! But have no fear, we can continue to use the my_number_or_zero function we created to protect us from these situations! Copy impl MyContract { /* --snip-- */ /// Set the value for the calling AccountId #[ink(message)] pub fn set_my_number(&mut self, value: u32) { let caller = self.env().caller(); self.my_number_map.insert(caller, value); } /// Add a value to the existing value for the calling AccountId #[ink(message)] pub fn add_my_number(&mut self, value: u32) { let caller = self.env().caller(); let my_number = self.my_number_or_zero(&caller); self.my_number_map.insert(caller, my_number + value); } /// Returns the number for an AccountId or 0 if it is not set. fn my_number_or_zero(&self, of: &AccountId) -> u32 { *self.my_number_map.get(of).unwrap_or(&0) } } Here we have written two kinds of functions which modify a HashMap. One which simply inserts the value directly into storage, with no need to read the value first, and the other which modifies the existing value. Note how we can always insert the value without worry, as that initialized the value in storage, but before you can get or modify anything, we need to call my_number_or_zero to make sure we are working with a real value. "},{"title":"Entry API","type":1,"pageTitle":"Working with Datastructures","url":"datastructures/hashmap#entry-api","content":"We will not always have an existing value on our contract's storage. We can take advantage of the Rust Option<T> type to help use on this task. If there's no value on the contract storage we will insert a new one; on the contrary if there is an existing value we will only update it. pro! HashMaps expose the well-known entry API that we can use to achieve this type of \"upsert\" behavior: Copy let caller = self.env().caller(); self.my_number_map .entry(caller) .and_modify(|old_value| old_value += by) .or_insert(by); "},{"title":"Overview","type":0,"sectionRef":"#","url":"datastructures/overview","content":"The ink_storage crate acts as the standard storage library for pro! smart contracts. It provides all the necessary tools and data structures to organize and operate the contract's storage intuitively and efficiently. You can find the crates documentation for all pro! data structures here. At the moment we provide these data structures: BinaryHeap: A priority queue implemented with a binary heap.BitStash A stash for bits operating on the contract storage.Bitvec A storage bit vector.HashMap A hash map operating on the contract storage.SmallVec A contiguous growable array type.Stash A stash data structure operating on contract storage.Vec A contiguous growable array type, written Vec<T> but pronounced 'vector'. Data structures provided by the ink_storage crate are inherently lazy; they are either high-level lazy or low-level lazy data structures. The difference between high-level and low-level lies in the distinction in how these data structures are aware of the elements that they operate on. For high-level data structures they are fully aware about the elements they contain, do all the clean-up by themselves so the user can concentrate on the business logic. For low-level data structures the responsibility about the elements lies in the hands of the contract author. Also they operate on cells (Option<T>) instead of entities of type T. But what does that mean exactly? The ink_storage::Lazy type caches their entities and acts lazily on the storage. This means that a read or write operation is only performed when it really needs to in order to satisfy other inputs. Data types such as Rust primitives i32 or Rust's very own Vec or data structures can also be used to operate on the contract's storage, however, they will load their contents eagerly which is often not what you want. An example follows with the below contract storage and a message that operates on either of the two fields. Copy #[ink(storage)] pub struct TwoValues { offset: i32, a: i32, b: i32, } impl TwoValues { #[ink(message)] pub fn set(&mut self, which: bool, new_value: i32) { match which { true => { self.a = self.offset + new_value; }, false => { self.b = self.offset + new_value; }, } } } Whenever we call TwoValues::set always both a and b are loaded despite the fact the we only operate on one of them at a time. This is very costly since storage accesses are in fact database look-ups. In order to prevent this eager loading of storage contents we can make use of ink_storage::Lazy or other lazy data structures defined in that crate: Copy #[ink(storage)] pub struct TwoValues { offset: i32, a: ink_storage::Lazy<i32>, b: ink_storage::Lazy<i32>, } impl TwoValues { #[ink(message)] pub fn set(&mut self, which: bool, new_value: i32) { match which { true => { self.a = offset + new_value; }, false => { self.b = offset + new_value; }, } } } Now a and b are only loaded when the contract really needs their values. Note that offset remained i32 since it is always needed and could spare the minor overhead of the ink_storage::Lazy wrapper.","keywords":""},{"title":"Spread vs. Packed","type":0,"sectionRef":"#","url":"datastructures/spread-packed-layout","content":"","keywords":""},{"title":"Storage Organization","type":1,"pageTitle":"Spread vs. Packed","url":"datastructures/spread-packed-layout#storage-organization","content":"The following schema depicts the storage which is exposed to pro! by the contracts pallet:  Storing or loading complex data structures to and from contract storage can be done in many different ways. You could store all information into a single storage cell or you could try to store all information into as many different cells as possible. Both strategies have pros and cons under different conditions. For example it might be a very good idea to store all the information under the same cell if all the information is very compact. For example when we are dealing with a byte vector that is expected to never be larger than approx a thousand elements it would probably be more efficient if we store all those thousand bytes in the same cell and especially if we often access many of those (or all) in our contract messages. On the other hand spreading information across as many cells as possible might be much more efficient if we are dealing with big data structures, a lot of information that is not compact, or when messages that operate on the data always only need a small fraction of the whole data. An example for this use case is if you have a vector of user accounts where each account stores potentially a lot of information, e.g. a 32-byte hash etc and where our messages only every operate on only a few of those at a time. The ink_storage crate provides the user full control over the strategy or a mix of these two root strategies through some fundamental abstractions that we are briefly presenting to you. "},{"title":"Default: Spreading Mode","type":1,"pageTitle":"Spread vs. Packed","url":"datastructures/spread-packed-layout#default-spreading-mode","content":"By default pro! spreads information to as many cells as possible. For example if you have the following #[ink(storage)] struct every field will live in its own single storage cell. Note that for c all 32 bytes will share the same cell! Copy #[ink(storage)] pub struct Spreaded { a: i32, b: ink_storage::Lazy<i32>, c: [u8; 32], } The following schema depicts the storage layout for a vector with three elements, persisted to storage in a spreaded layout.  "},{"title":"Packing Storage","type":1,"pageTitle":"Spread vs. Packed","url":"datastructures/spread-packed-layout#packing-storage","content":"We can alter this behaviour by using the ink_storage::Pack abstraction: Copy pub struct Spreaded { a: i32, b: ink_storage::Lazy<i32>, c: [u8; 32], } #[ink(storage)] pub struct Packed { packed: ink_storage::Pack<Spreaded>, } Now all fields of Spreaded will share the same storage cell. This means whenever one of them is stored to or loaded from the contract storage, all of them are stored or loaded. A user has to choose wisely what mode of operation is more suitable for their contract. These abstractions can be combined in various ways, yielding full control to the users. For example, in the following only a and b share a common storage cell while c lives in its own: Copy pub struct Spreaded { a: i32, b: ink_storage::Lazy<i32>, } #[ink(storage)] pub struct Packed { packed: ink_storage::Pack<Spreaded>, c: [u8; 32], } The following schema depicts the spreaded vector from the previous section in a packed layout.  "},{"title":"Spreading Array Cells","type":1,"pageTitle":"Spread vs. Packed","url":"datastructures/spread-packed-layout#spreading-array-cells","content":"If we prefer to store all bytes of c into their own storage cell we can make use of the SmallVec data structure. The SmallVec is a high-level data structure that allows to efficiently organize a fixed number of elements similar to a Rust array. However, unlike a Rust array it acts lazily upon the storage and spreads its elements into different cells. Copy use typenum::U32; pub struct Spreaded { a: i32, b: ink_storage::Lazy<i32>, } #[ink(storage)] pub struct Packed { packed: ink_storage::Pack<Spreaded>, c: SmallVec<u8, U32>, } "},{"title":"Overview","type":0,"sectionRef":"#","url":"examples","content":"In our examples folder you find a number of examples written in pro!. Some of the most interesting ones: delegator ‒ Implements cross-contract calling.trait-erc20 ‒ Defines a trait for Erc20 contracts and implements it.erc721 ‒ An exemplary implementation of Erc721 NFT tokens.dns ‒ A simple DomainNameService smart contract.…and more, just rummage through the folder 🙃. To build a single example navigate to the root of the example and run: Copy cargo contract build As a result you'll get a file target/flipper.wasm file, a metadata.json file and a <contract-name>.contract file in the target/ folder of your contract. The .contract file combines the Wasm and metadata into one file and needs to be used when deploying the contract. For further information, please have a look at the Play with It section or our smart contracts workshop.","keywords":""},{"title":"Compile Your Contract","type":0,"sectionRef":"#","url":"getting-started/building-your-contract","content":"Run the following command to compile your smart contract: Copy cargo +nightly contract build This special command will turn your pro! project into a Wasm binary, a metadata file (which contains the contract's ABI) and a .contract file which bundles both. This .contract file can be used for deploying your contract to your chain. If all goes well, you should see a target folder which contains these files: Copy target └── flipper.wasm └── metadata.json └── flipper.contract Let's take a look at the structure of the metadata.json: Copy { \"registry\": { \"strings\": [...], \"types\": [...] }, \"storage\": {...}, \"contract\": { \"name\": ..., \"constructors\": [...], \"messages\": [...], \"events\": [], \"docs\": [] } } You can see that this file describes all the interfaces that can be used to interact with your contract. Registry provides the strings and custom types used throughout the rest of the JSON.Storage defines all the storage items managed by your contract and how to ultimately access them.Contract stores information about the callable functions like constructors and messages a user can call to interact with your contract. It also has helpful information like the events that are emitted by the contract or any docs. If you look close at the constructors and messages, you will also notice a selector which is a 4-byte hash of the function name and is used to route your contract calls to the correct functions. The Canvas UI uses this file to generate a friendly interface for deploying and interacting with your contract. :) In the next section we will start a Canvas node and configure the Canvas UI to interact with it.","keywords":""},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"faq","content":"","keywords":""},{"title":"Is it \"ink\" or \"pro!\"? What does the \"!\" stand for?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#is-it-ink-or-ink-what-does-the--stand-for","content":"The DSL (domain specific language) is spelled \"pro!\" with small \"i\" and an exclamation mark at the end. The main purpose behind this spelling is to have as many dots in its name as possible. "},{"title":"Who is \"Squink\"?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#who-is-squink","content":"This little cute purle squid is Squink. Squink is the mascot of pro! and guides new users and adventurers through our presentations workshops and tutorials. It also has a romance with Rust's mascot, Ferris. Generally it is very friendly and open to learning new Rustaceans but be aware to never upset it by taking away dots from the word pro! by spelling it incorrectly! It really is into dots. Stories tell that it demanded the spelling of pro! with as many dots as possible. "},{"title":"What's pro!'s relationship to Substrate/Polkadot?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#whats-inks-relationship-to-substratepolkadot","content":"Substrate is a modular framework to build decentralized applications on top of blockchain technology.Polkadot is a layer-0 blockchain built using Substrate that allows to orchestrate an entire fleet of other blockchains to join forces and communicate with each other.Blockchains built with Substrate can include the so-called contracts-pallet module in order to allow instantiating and executing smart contracts. pro! was built to allow users to write smart contracts in Rust targeting blockchains built by Substrate that have the aforementioned contracts-pallet included. While pro! is currently the most advanced smart contract language targeting Substrate blockchains it is not the only possible choice for users. There is also a Solidity to Wasm compiler called Solang that also allows to target Substrate chains and there are other languages in plan and discovery phase for the same purpose. On the Substrate side the same is true for the contracts-pallet. It is just a module that defines the basic set of features required for executing smart contracts on the blockchain that includes it. However, it is not necessarily the only solution to do exactly that. There is also the evm-palletto run smart contracts targeting the EVM as well as the experimental actors-pallet that allows to execute smart contracts written in the actor style programming model. Over time the Substrate community might come up with yet other pallets for smart contracts execution. "},{"title":"How to call other smart contracts on the same blockchain?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-to-call-other-smart-contracts-on-the-same-blockchain","content":"See the Cross-contract calling section. "},{"title":"How to call other smart contracts on another parachain?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-to-call-other-smart-contracts-on-another-parachain","content":"This feature has not yet been implemented by the Substrate side. "},{"title":"What is a contract's ABI or Metadata?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-is-a-contracts-abi-or-metadata","content":"In pro! a smart contract's metadata is retrieved by using the cargo-contract CLI tool and invoking cargo contract build which outputs a .contract file that includes both the compiled.wasm of the pro! smart contract as well as the so-called metadata information of the same smart contract. The metadata is especially important for third party tools such as Polkadot JS Apps or the Canvas UI and provides useful information about the contract's constructors, messages, events, function selectors, documentation and comments of the aforementioned structures as well as how inputs and outputs shall be encoded and decoded respectively etc. "},{"title":"Can a re-entrancy bug occur in pro! contracts?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#can-a-re-entrancy-bug-occur-in-ink-contracts","content":"Yes. However, the Substrate team is well aware of the associated problems and already through about possible future additions to eliminate re-entrancy attacks. "},{"title":"How can my smart contract interact with the runtime?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-can-my-smart-contract-interact-with-the-runtime","content":"See the Chain Extensions section for more information. "},{"title":"How can I use pro! with a Substrate chain with a custom chain config?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-can-i-use-ink-with-a-substrate-chain-with-a-custom-chain-config","content":"Please see the env_types argumentfor the contract macro. It allows you to specify your environment a la#[ink::contract(env = MyEnvironment)]. "},{"title":"What does the #![cfg_attr(not(feature = \"std\"), no_std)] at the beginning of each contract mean?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-does-the-cfg_attrnotfeature--std-no_std-at-the-beginning-of-each-contract-mean","content":"The #[cfg(..)] or #[cfg_attr(..)] annotations are how Rust does conditional compilation. pro! smart contracts can be compiled in two different modes. Through #![cfg_attr(not(feature = \"std\"), no_std)] an pro! smart contract tells the Rust compiler in which mode they are being compiled. This also plays a significant role in how pro! generates the smart contract code. The two modes are as follows: Wasm mode: This is the mode chosen when compiling an pro! smart contract for deployment on a blockchain. The resulting binary is a .wasm file and as such it is not possible to use certain parts of Rust's standard library.Off-chain mode: This is the mode chosen when trying to test an pro! smart contract using the off-chain environment. Off-chain environment testing is very useful to check if certain pro! constructors or messages are well behaving and allow for better debuggability than when trying to debug the same smart contract deployed on a chain. "},{"title":"Overflow Safety?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#overflow-safety","content":"Being written in Rust, pro! can provide compile-time overflow/underflow safety. Using a Rust compiler configuration, you can specify whether you want to support overflowing math, or if you want contract execution to panic when overflows occur. No need to continually import \"Safe Math\" libraries, although Rust also provides integrated checked, wrapped, and saturated math functions. Note: There are some known issues regarding functionality of compiler level overflow checks and the resulting size of the Wasm blob. This feature may change or be iterated on in the future. "},{"title":"What is the difference between memory and storage?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#what-is-the-difference-between-memory-and-storage","content":"In pro!, memory refers to computer memory, while storage refers to the on-chain storage used by a contract instance. Memory is temporary and only lasts until the contract execution is done, while storage is persistent and lasts over many contract executions. The contract storage is built on top of the runtime storage, and access is considered to be slow. "},{"title":"How do I print something to the console from the runtime?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-do-i-print-something-to-the-console-from-the-runtime","content":"In your pro! message or constructor write the following: Copy #[ink(constructor)] fn print_contents_1(contents: &str) -> Self { Self::env().debug_println(contents); Self { .. } } #[ink(message)] fn print_contents_2(&self, contents: &str) { self.env().debug_println(contents); } Note that this will only print to console if the smart contract is either tested off-chain or if it is run on an on-chain with --dev (development) configuration. Trying to deploy a smart contract that uses debug_println will always fail for non --dev chains. "},{"title":"Is it possible to do println!(\"{:?}\", foo) on-chain for debugging purposes?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#is-it-possible-to-do-println-foo-on-chain-for-debugging-purposes","content":"The pro! team has not yet provided a cleaner solution than using self.env().debug_println(..) as mentioned in the last question. The debug_println method only takes a static str argument which cannot be formatted. However, it is possible to use Rust's format! macro in order to have the same benefits in the end: Copy #[ink(message)] fn print_formatted(&self, contents: &str) { self.env().debug_println(&format!(\"message: {}\", contents)); } Note that it might be required to import the format! macro from the ink_prelude crate first. "},{"title":"Why is Rust's standard library (stdlib) not available in pro!?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-is-rusts-standard-library-stdlib-not-available-in-ink","content":"Rust's standard library consists of three different layers: core library which defines everything that has no dependencies outside of Rust itself. Included are types such as Option, Result as well as a whole variety of modules, functions and macro. pro! smart contracts allow authors to use Rust's core crate. alloc library which is depending on a global allocator and mainly defines collections that spill their elements on to the execution's heap memory. Examples for collections are Box, String, Vec, HashMap, LinkedList and modules such as fmt, rc (ref-counted pointers) or borrows. pro! smart contracts allow authors to use Rust's alloc crate. By default pro! authors use definitions from the alloc crate through ink_prelude crate. std library is what people generally call Rust's standard library. The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem. It requires several operating system capabilities in order to work correctly such as input and output systems for files, networking etc. Since the Wasm (a.k.a. wasm32-unknown-unknown) compilation target does not support Rust's standard library pro! authors cannot use it either for their own purposes. Instead the contracts-pallettries to provide some common functionality that would otherwise be missing for common smart contract operations. "},{"title":"Why is nightly required for pro!?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-is-nightly-required-for-ink","content":"pro! requires a nightly Rust compiler as of 2021-01 since it relies on a few unstable nightly features around allocation handlers for no_std (no standard library) code. As soon as the Rust team decides to stabilize these features pro! will be available for stable Rust. "},{"title":"How do I hash a value?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#how-do-i-hash-a-value","content":"A number of crypto hashes are built into the contracts-pallet and therefore very efficient to use. We currently support a handful of those, you can view the complete list here. If you have the urgent need for another crypto hash you could introduce it throughChain Extensionsor make a proposal to include it into the default set of the contracts-pallet. Using one of the built-in crypto hashes an be done like this: Copy use ink_env::hash::Blake2x256; let hashed1: [u8; 32] = self.env().hash_bytes::<Blake2x256>(my_bytes); let hashed2: [u8; 32] = self.env().hash_encoded::<Blake2x256>(42); "},{"title":"When to use Lazy<T> over just T for a contract field?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#when-to-use-lazyt-over-just-t-for-a-contract-field","content":"The ink_storage::Lazy type caches their entities and acts lazily on the storage. This means that a read or write operation is only performed when it really needs to in order to satisfy other inputs. Data types such as Rust primitives i32 or Rust's very own Vec or data structures can also be used to operate on the contract's storage, however, they will load their contents eagerly which is often not what you want. See this chapter where we go into more details and provide examples. "},{"title":"Why is it not possible to use floating point data types in pro!? How do I implement returning a decimal number?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-is-it-not-possible-to-use-floating-point-data-types-in-ink-how-do-i-implement-returning-a-decimal-number","content":"Floats are cool for all kinds of reasons, but they also have one important drawback. Floating point arithmetic is non-deterministic which means that different processors compute (slightly) different results for the same operation. Although there is an IEEE spec, non-determinism can come from specific libraries used, or even hardware. In order for the nodes in a blockchain network to reach agreement on the state of the chain, all operations must be completely deterministic. Hence we don't allow floating point data types in pro!. Consequently it's not possible to return a decimal number from an pro! message. What you should do instead is to have your user interface denominate the returned number to decimals. Note, that it's typical for blockchains to have the number of available tokens defined as a non-floating number and determine the denomination in the user interface. For example, 1 Bitcoin is equivalent to the smallest unit of 100,000,000 Satoshi and all Bitcoin implementations internally persist account balances in Satoshi, not as a decimal number of Bitcoin. "},{"title":"Why can't I just use the standard Rust data collections in pro!?","type":1,"pageTitle":"Frequently Asked Questions","url":"faq#why-cant-i-just-use-the-standard-rust-data-collections-in-ink","content":"You can use them! They are exposed via the ink_prelude crate (e.g. ink_prelude::vec::Vec) and you can return them from pro! messages and also persist them to storage. However, the Rust stdlib collections are not optimized for smart contract usage! So for example, if you use them to persist your data on the chain they will always occupy a single storage cell and thus always be loaded eagerly, in their entirety. This can be very costly! Just think about a Vec or a HashMap where the smart contract might only need access to a few elements, rather than the entire data collection. Our ink_storage data structures on the other hand are optimized for storage and provide a differentiation between lazy and eager access. See this chapter where we go into more details and provide examples. "},{"title":"Call Your Contract","type":0,"sectionRef":"#","url":"getting-started/calling-your-contract","content":"","keywords":""},{"title":"get()","type":1,"pageTitle":"Call Your Contract","url":"getting-started/calling-your-contract#get","content":"If you take a look back at our contract's default() function, we set the initial value of the Flipper contract to false. Let's check that this is the case. In the Message to Send section, select the \"get(): bool\" message and accept the default values for the other options. Press \"Call\" and confirm that it returns the value false:  NOTE: You might be wondering: \"Why did we need to specify gas when reading a value from a contract?\" If you notice right above the \"Call\" button is a select box that allows you to \"Send call as RPC call\" or \"Send as transaction\". For a read-only request like this, we can simply use an RPC call which will simulate a transaction, but not actually store anything on-chain. Thus, you will still need to specify the right amount of gas to cover your \"virtual fee\", but don't worry, nothing will be charged when making a call this way. :) "},{"title":"flip()","type":1,"pageTitle":"Call Your Contract","url":"getting-started/calling-your-contract#flip","content":"So let's make the value turn true now! The alternative message to send we can make with the UI is flip(). Again, accept the default values for the other options. You will notice that the flip() message defaults to a transaction call.  If the transaction was successful, we should then be able to go back to the get() function and see our updated storage:  Woohoo! You deployed your first smart contract! "},{"title":"Moving Forward","type":1,"pageTitle":"Call Your Contract","url":"getting-started/calling-your-contract#moving-forward","content":"If you are looking for a guided tutorial on how to build a more complex smart contract you might want to check out our ERC-20 tutorial. "},{"title":"Deploy Your Contract","type":0,"sectionRef":"#","url":"getting-started/deploy-your-contract","content":"","keywords":""},{"title":"Putting Your Code on the Blockchain","type":1,"pageTitle":"Deploy Your Contract","url":"getting-started/deploy-your-contract#putting-your-code-on-the-blockchain","content":"Open the specially designed Upload section of the Canvas UI. Use the dropdown to select a deployment account with some account balance, like Alice. Enter a name for the contract in the input field. Provide the flipper.contract file as the bundled Wasm blob and metadata.  Click Upload and then Sign & Submit on the confirmation page. This should emit a contracts.PutCode event. If the transaction succeeds you will get an system.ExtrinsicSuccess event and your WASM contract will be stored on your Substrate blockchain!  "},{"title":"Creating an Instance of Your Contract","type":1,"pageTitle":"Deploy Your Contract","url":"getting-started/deploy-your-contract#creating-an-instance-of-your-contract","content":"Smart contracts exist as an extension of the account system on the blockchain. Thus creating an instance of this contract will create a new AccountId which will store any balance managed by the smart contract and allow us to interact with the contract. After you uploaded the contract in the previous step, a confirmation screen displays the information that represents our smart contract. We now need to deploy our smart contract to create an instance. Press the \"Deploy Code\" button on the confirmation screen. To instantiate our contract, accept the default options to give this contract account an endowment of 1000 Units in order to pay the storage rent and set a maximum gas allowed value of 1000000:  Note: As mentioned earlier, contract creation involves creation of a new Account. As such, you must be sure to give the contract account at least the existential deposit defined by your blockchain. We also need to be able to pay the contract's rent (endowment). If we consume all of this deposit, the contract will become invalid. We can always refill the contract's balance and keep it on chain. When you press Deploy, you should see a flurry of events appear including the creation of a new account (system.NewAccount) and the instantiation of the contract (contracts.instantiate):  "},{"title":"Run a Substrate Node","type":0,"sectionRef":"#","url":"getting-started/running-substrate","content":"The canvas-node is a simple Substrate blockchain which is configured to include the contracts module. It's a comfortable option if you want to get a quickstart. After successfully installing canvas, you can start a local development chain by running: Copy canvas --dev --tmp You should start to see blocks being produced by your node in your terminal. You can interact with your node using the Canvas UI: https://paritytech.github.io/canvas-ui The UI will connect to the locally running node by default.","keywords":""},{"title":"Creating an pro! Project","type":0,"sectionRef":"#","url":"getting-started/creating-an-ink-project","content":"","keywords":""},{"title":"Contract Source Code","type":1,"pageTitle":"Creating an pro! Project","url":"getting-started/creating-an-ink-project#contract-source-code","content":"The ink CLI automatically generates the source code for the \"Flipper\" contract, which is about the simplest \"smart\" contract you can build. You can take a sneak peak as to what will come by looking at the source code here: Flipper Example Source Code The Flipper contract is nothing more than a bool which gets flipped from true to false through the flip() function. "},{"title":"Testing Your Contract","type":1,"pageTitle":"Creating an pro! Project","url":"getting-started/creating-an-ink-project#testing-your-contract","content":"You will see at the bottom of the source code there is a simple test which verifies the functionality of the contract. We can quickly test that this code is functioning as expected using the off-chain test environment that pro! provides. In your project folder run: Copy cargo +nightly test To which you should see a successful test completion: Copy $ cargo +nightly test running 2 tests test flipper::tests::it_works ... ok test flipper::tests::default_works ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Now that we are feeling confident things are working, we can actually compile this contract to Wasm in the next step. "},{"title":"Setup","type":0,"sectionRef":"#","url":"getting-started/setup","content":"","keywords":""},{"title":"Rust & Cargo","type":1,"pageTitle":"Setup","url":"getting-started/setup#rust--cargo","content":"A prerequisite for compiling smart contracts is to have Rust and Cargo installed. Here's an installation guide. "},{"title":"pro! CLI","type":1,"pageTitle":"Setup","url":"getting-started/setup#ink-cli","content":"The first tool we will be installing is cargo-contract, a CLI tool for helping setting up and managing WebAssembly smart contracts written with pro!. You can install the utility using Cargo with: Copy cargo install cargo-contract --vers 0.8.0 --force --locked Use the --force to ensure you are updated to the most recent cargo-contract version. You can then use cargo contract --help to start exploring the commands made available to you. "},{"title":"Substrate Framework Prerequisites","type":1,"pageTitle":"Setup","url":"getting-started/setup#substrate-framework-prerequisites","content":"With pro! you can write smart contracts for blockchains built on Substrate. Follow theofficial installation steps from the Substrate Developer Hub Knowledge Base to set up all Substrate prerequisites. Copy rustup component add rust-src --toolchain nightly rustup target add wasm32-unknown-unknown --toolchain stable "},{"title":"Installing The Canvas Node","type":1,"pageTitle":"Setup","url":"getting-started/setup#installing-the-canvas-node","content":"The canvas-node is a simple Substrate blockchain which is configured to include the Substrate module for smart contract functionality ‒ the contracts pallet (see How it Works for more). It's a comfortable option if you want to get a quickstart. Copy cargo install canvas-node --git https://github.com/paritytech/canvas-node.git --tag v0.1.3 --force --locked "},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"getting-started/troubleshooting","content":"","keywords":""},{"title":"Unexpected Epoch Change","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#unexpected-epoch-change","content":"There is a known issue with the Substrate block production (BABE) on a running chain. If you stop your node for too long (closing the terminal, putting your computer to sleep, etc.), you will get the following error: Copy ClientImport(\"Unexpected epoch change\") To solve this you will need to restart your node with: canvas --dev --tmp. At that point, you will need to re-deploy any contracts and re-do any steps that you may have done before on your node. As long as you keep your node running, you should face no issues. "},{"title":"Old Contracts in Local Storage","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#old-contracts-in-local-storage","content":"The Polkadot UI uses its own local storage to track the contracts that you have deployed. This means that if you deploy a contract using the UI, and then purge your Canvas node, you will still see the old contracts in the UI even though they do not exist on-chain! You can simply remove any old artifacts from the UI or reset your local storage. So remember, when you start a new chain with the --tmp flag or use the purge-chain subcommand, you will need to re-deploy any contracts and re-do any steps that you may have done before on your node. "},{"title":"Transaction vs RPC","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#transaction-vs-rpc","content":"When interacting with contracts using the Canvas UI, you have the option to submit your calls as a transaction or via the RPC:  When you send as a transaction, it should be exactly as you expect. A transaction is submitted to contract, a fee is deducted from your account, and the state of your blockchain can change. In these situations, no value is returned from your contract calls, only a \"Success\" or \"Failed\" extrinsic message along with any events you emit. However, there may be some calls that you want to \"test\", rather than actually submit a transaction. Or you may want to peek at the value that would be returned if you called the contract function. For these scenarios, you can submit an RPC call, which will run all of your contract logic, but not actually submit a transaction or update the state of your chain. However, you will still need to specify the right amount of gas to cover your \"virtual fee\", but don't worry, nothing will be charged when making a call this way. :) "},{"title":"Contract State Rent","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#contract-state-rent","content":"The Substrate contracts pallet has a state rent system that forces contracts to stay funded if they want to stay on the blockchain. This means that the more you use a contract, the more fees are taken from it, and at some point, the contract will run out of fees and turn into a non-functioning tombstone. We try to avoid this by giving the contract a large endowment when we initially deploy it. However, if your contract does become a tombstone, for the purposes of this tutorial, the best solution is to just redeploy your contract to the chain. The best way to prevent this in general is to make sure your contract stays well funded. In real world scenarios, there is a process that you can go through to recover a tombstone contract and get it functioning again, however this is beyond the scope of this tutorial. "},{"title":"Other Issues","type":1,"pageTitle":"Troubleshooting","url":"getting-started/troubleshooting#other-issues","content":"If you run into any other issues during this tutorial, please report an issue! "},{"title":"How it Works ‒ Substrate","type":0,"sectionRef":"#","url":"how-it-works","content":"Substrate's Framework for Runtime Aggregation of Modularised Entities (FRAME) contains a module which implements an API for typical functions smart contracts need (storage, querying information about accounts, …). This module is called the contracts pallet, you can find its repository here. The contracts pallet requires smart contracts to be uploaded to the blockchain as a Wasm blob. pro! is a smart contract language which targets the API exposed by contracts. Hence pro! contracts are compiled to Wasm. When executing cargo contract build an additional file metadata.json is created. It contains information about e.g. what methods the contract provides for others to call.","keywords":""},{"title":"pro! vs. Solidity","type":0,"sectionRef":"#","url":"ink-vs-solidity","content":"Here is a brief comparison of features between pro! and Solidity: pro!\tSolidityVirtual Machine\tAny Wasm VM\tEVM Encoding\tWasm\tEVM Byte Code Language\tRust\tStandalone Overflow Protection\tEnabled by default\tNone Constructor Functions\tMultiple\tSingle Tooling\tAnything that supports Rust\tCustom Versioning\tSemantic\tSemantic Has Metadata?\tYes\tYes Multi-File Project\tPlanned\tYes Storage Entries\tVariable\t256 bits Supported Types\tDocs\tDocs Has Interfaces?\tYes (Rust Traits)\tYes","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"macros-attributes","content":"","keywords":""},{"title":"Merging Attributes","type":1,"pageTitle":"Overview","url":"macros-attributes#merging-attributes","content":"It is possible to merge attributes that share a common flagged entity. The example below demonstrates this for a payable message with a custom selector. Copy #[ink(message)] #[ink(payable)] #[ink(selector = \"0xCAFEBABE\")] pub fn transfer(&mut self, from: AccountId, to: AccountId, value: Balance) -> Result<(), Error> { // actual implementation } We can also write the above pro! message definition in the following way: Copy #[ink(message, payable, selector = \"0xCAFEBABE\")] pub fn transfer(&mut self, from: AccountId, to: AccountId, value: Balance) -> Result<(), Error> { // actual implementation } "},{"title":"#[ink(anonymous)]","type":0,"sectionRef":"#","url":"macros-attributes/anonymous","content":"Applicable to pro! events. Tells the pro! codegen to treat the pro! event as anonymous which omits the event signature as topic upon emitting. Very similar to anonymous events in Solidity. Anonymous events have similar semantics as in Solidity in that their event signature won't be included in their event topics serialization to reduce event emitting overhead. This is especially useful for user defined events. The signature of the event is by default one of the topics of the event, except if you annotate the event with #[ink(anonymous)]. The attribute implies that it is not possible to filter for specific anonymous events by name.","keywords":""},{"title":"#[ink(constructor)]","type":0,"sectionRef":"#","url":"macros-attributes/constructor","content":"","keywords":""},{"title":"Example","type":1,"pageTitle":"#[ink(constructor)]","url":"macros-attributes/constructor#example","content":"Copy use ink_lang as ink; #[ink::contract] mod erc20 { #[ink(storage)] pub struct Erc20 { ... } impl Erc20 { #[ink(constructor)] pub fn new(initial_supply: Balance) -> Self { .. } #[ink(constructor)] pub fn total_supply(&self) -> Balance { .. } // etc. } } "},{"title":"#[ink::contract]","type":0,"sectionRef":"#","url":"macros-attributes/contract","content":"","keywords":""},{"title":"Header Arguments","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#header-arguments","content":"The #[ink::contract] macro can be provided with some additional comma-separated header arguments: "},{"title":"dynamic_storage_allocator: bool","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#dynamic_storage_allocator-bool","content":"Tells the pro! code generator to allow usage of pro!'s built-in dynamic storage allocator. true: Use the dynamic storage allocator provided by pro!.false: Do NOT use the dynamic storage allocator provided by pro!. This feature is generally only needed for smart contracts that try to model their data in a way that contains storage entites within other storage entities. Contract writers should try to write smart contracts that do not depend on the dynamic storage allocator since enabling it comes at a cost of increased Wasm file size. Although it will enable interesting use cases. Use it with care! An example for this is the following type that could potentially be used within a contract's storage struct definition: Copy // A storage vector of storage vectors. use ink_storage as storage; type VectorOfVectors = storage::Vec<storage::Vec<i32>>; Usage Example: Copy use ink_lang as ink; #[ink::contract(dynamic_storage_allocator = true)] mod my_contract { #[ink(storage)] pub struct MyStorage; impl MyStorage { #[ink(constructor)] pub fn construct() -> Self { MyStorage {} } #[ink(message)] pub fn message(&self) {} } // ... } Default value: false "},{"title":"compile_as_dependency: bool","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#compile_as_dependency-bool","content":"Tells the pro! code generator to always or nevercompile the smart contract as if it was used as a dependency of another pro! smart contract. Normally this flag is only really useful for pro! developers who want to inspect code generation of pro! smart contracts. The author is not aware of any particular practical use case for users that makes use of this flag but contract writers are encouraged to disprove this. Note that it is recommended to make use of the built-in crate featureink-as-dependency to flag smart contract dependencies listed in a contract'sCargo.toml as actual dependencies to pro!. Usage Example: Copy use ink_lang as ink; #[ink::contract(compile_as_dependency = true)] mod my_contract { #[ink(storage)] pub struct MyStorage; impl MyStorage { #[ink(constructor)] pub fn construct() -> Self { MyStorage {} } #[ink(message)] pub fn message(&self) {} } // ... } Default value: Depends on the crate feature propagation of Cargo.toml. "},{"title":"env: impl Environment","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#env-impl-environment","content":"Tells the pro! code generator which environment to use for the pro! smart contract. The environment must implement the Environment (defined in ink_env) trait and provides all the necessary fundamental type definitions for Balance, AccountId etc. When using a custom Environment implementation for a smart contract all types that it exposes to the pro! smart contract and the mirrored types used in the runtime must be aligned with respect to SCALE encoding and semantics. Usage Example: Given a custom Environment implementation: Copy pub struct MyEnvironment; impl ink_env::Environment for MyEnvironment { const MAX_EVENT_TOPICS: usize = 3; type AccountId = u64; type Balance = u128; type Hash = [u8; 32]; type Timestamp = u64; type BlockNumber = u32; type ChainExtension = ::ink_env::NoChainExtension; } A user might implement their pro! smart contract using the above custom Environmentimplementation as demonstrated below: Copy use ink_lang as ink; #[ink::contract(env = MyEnvironment)] mod my_contract { pub struct MyEnvironment; impl ink_env::Environment for MyEnvironment { const MAX_EVENT_TOPICS: usize = 3; type AccountId = u64; type Balance = u128; type Hash = [u8; 32]; type Timestamp = u64; type BlockNumber = u32; type ChainExtension = ::ink_env::NoChainExtension; } #[ink(storage)] pub struct MyStorage; impl MyStorage { #[ink(constructor)] pub fn construct() -> Self { MyStorage {} } #[ink(message)] pub fn message(&self) {} } // ... } Default value: DefaultEnvironment defined in ink_env crate. "},{"title":"Anaylsis","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#anaylsis","content":"The #[ink::contract] macro fully analyses its input smart contract against invalid arguments and structure. Some example rules include but are not limited to: There must be exactly one #[ink(storage)] struct. This struct defines the layout of the storage that the pro! smart contract operates on. The user is able to use a variety of built-in facilities, combine them in various ways or even provide their own implementations of storage data structures. For more information visit the ink_storage crate documentation. Example: Copy use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn construct() -> Self { Flipper { value: false } } #[ink(message)] pub fn message(&self) {} } } There must be at least one #[ink(constructor)] defined method. Methods flagged with #[ink(constructor)] are special in that they are dispatchable upon contract instantiation. A contract may define multiple such constructors which allow users of the contract to instantiate a contract in multiple different ways. Example: Given the Flipper contract definition above we add an #[ink(constructor)]as follows: Copy use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn new(initial_value: bool) -> Self { Flipper { value: false } } #[ink(message)] pub fn message(&self) {} } } There must be at least one #[ink(message)] defined method. Methods flagged with #[ink(message)] are special in that they are dispatchable upon contract invocation. The set of pro! messages defined for an pro! smart contract define its API surface with which users are allowed to interact. An pro! smart contract can have multiple such pro! messages defined. Note: An pro! message with a &self receiver may only read state whereas an pro! message with a &mut self receiver may mutate the contract's storage. Example: Given the Flipper contract definition above we add some #[ink(message)] definitions as follows: Copy use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn new(initial_value: bool) -> Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] pub fn flip(&mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message)] pub fn get(&self) -> bool { self.value } } } Payable Messages: An pro! message by default will reject calls that additional fund the smart contract. Authors of pro! smart contracts can make an pro! message payable by adding the payableflag to it. An example below: Note that pro! constructors are always implicitly payable and thus cannot be flagged as such. Copy use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn new(initial_value: bool) -> Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] #[ink(payable)] // You can either specify payable out-of-line. pub fn flip(&mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message, payable)] // ... or specify payable inline. pub fn get(&self) -> bool { self.value } } } Controlling the messages selector: Every pro! message and pro! constructor has a unique selector with which the message or constructor can be uniquely identified within the pro! smart contract. These selectors are mainly used to drive the contract's dispatch upon calling it. An pro! smart contract author can control the selector of an pro! message or pro! constructor using the selector flag. An example is shown below: Copy use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] #[ink(selector = \"0xDEADBEEF\")] // Works on constructors as well. pub fn new(initial_value: bool) -> Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] #[ink(selector = \"0xCAFEBABE\")] // You can either specify selector out-of-line. pub fn flip(&mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message, selector = \"0xFEEDBEEF\")] // ... or specify selector inline. pub fn get(&self) -> bool { self.value } } } "},{"title":"Interacting with the Contract Executor","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#interacting-with-the-contract-executor","content":"The ink_env crate provides facitilies to interact with the contract executor that connects pro! smart contracts with the outer world. For example it is possible to query the current call's caller via: Copy use ink_env; ink_env::test::run_test::<ink_env::DefaultEnvironment, _>(|_| { let caller = ink_env::caller::<ink_env::DefaultEnvironment>(); let _caller = caller; Ok(()) }).unwrap(); However, pro! provides a much simpler way to interact with the contract executor via its environment accessor. An example below: Copy use ink_lang as ink; #[ink::contract] mod greeter { #[ink(storage)] pub struct Greeter; impl Greeter { #[ink(constructor)] pub fn new() -> Self { let caller = Self::env().caller(); let message = format!(\"thanks for instantiation {:?}\", caller); ink_env::debug_println(&message); Greeter {} } #[ink(message, payable)] pub fn fund(&mut self) { let caller = self.env().caller(); let value = self.env().transferred_balance(); let message = format!(\"thanks for the funding of {:?} from {:?}\", value, caller); ink_env::debug_println(&message); } } } "},{"title":"Events","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#events","content":"An pro! smart contract may define events that it can emit during contract execution. Emitting events can be used by third party tools to query information about a contract's execution and state. The following example pro! contract shows how an event Transferred is defined and emitted in the #[ink(constructor)]. Copy use ink_lang as ink; #[ink::contract] mod erc20 { /// Defines an event that is emitted every time value is transferred. #[ink(event)] pub struct Transferred { from: Option<AccountId>, to: Option<AccountId>, value: Balance, } #[ink(storage)] pub struct Erc20 { total_supply: Balance, // more fields ... } impl Erc20 { #[ink(constructor)] pub fn new(initial_supply: Balance) -> Self { let caller = Self::env().caller(); Self::env().emit_event(Transferred { from: None, to: Some(caller), value: initial_supply, }); Self { total_supply: initial_supply } } #[ink(message)] pub fn total_supply(&self) -> Balance { self.total_supply } } } "},{"title":"Example: Flipper","type":1,"pageTitle":"#[ink::contract]","url":"macros-attributes/contract#example-flipper","content":"The below code shows the complete implementation of the so-called Flipper pro! smart contract. For us it acts as the \"Hello, World!\" of the pro! smart contracts because it is minimal while still providing some more or less useful functionality. It controls a single bool value that can be either false or trueand allows the user to flip this value using the Flipper::flip message or retrieve the current value using Flipper::get. Copy use ink_lang as ink; #[ink::contract] pub mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { /// Creates a new flipper smart contract initialized with the given value. #[ink(constructor)] pub fn new(init_value: bool) -> Self { Self { value: init_value } } /// Flips the current value of the Flipper's bool. #[ink(message)] pub fn flip(&mut self) { self.value = !self.value; } /// Returns the current value of the Flipper's bool. #[ink(message)] pub fn get(&self) -> bool { self.value } } } "},{"title":"#[ink::chain_extension]","type":0,"sectionRef":"#","url":"macros-attributes/chain-extension","content":"","keywords":""},{"title":"Structure","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#structure","content":"The interface consists of an error code that indicates lightweight errors as well as the definition of some chain extension methods. The overall structure follows that of a simple Rust trait definition. The error code is defined as an associated type definition of the trait definition. The methods are defined as associated trait methods without implementation. Chain extension methods must not have a self receiver such as &self or &mut selfand must have inputs and output that implement SCALE codec. Their return value follows specific rules that can be altered using the handle_status and returns_result attributes which are described in more detail below. "},{"title":"Usage","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#usage","content":"Usually the chain extension definition using this proc. macro is provided by the author of the chain extension in a separate crate. pro! smart contracts using this chain extension simply depend on this crate and use its associated environment definition in order to make use of the methods provided by the chain extension. "},{"title":"Attributes","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#attributes","content":"There are three different attributes with which the chain extension methods can be flagged: Attribute\tRequired\tDefault Value\tDescriptionink(extension = N: u32)\tYes\t-\tDetermines the unique function ID of the chain extension method. ink(handle_status = flag: bool)\tOptional\ttrue\tAssumes that the returned status code of the chain extension method always indicates success and therefore always loads and decodes the output buffer of the call. ink(returns_result = flag: bool)\tOptional\ttrue\tBy default chain extension methods are assumed to return a Result<T, E> in the output buffer. Using returns_result = false this check is disabled and the chain extension method may return any other type. As with all pro! attributes multiple of them can either appear in a contiguous list: Copy type Access = i32; use ink_lang as ink; #[ink::chain_extension] pub trait MyChainExtension { type ErrorCode = i32; #[ink(extension = 5, handle_status = false, returns_result = false)] fn key_access_for_account(key: &[u8], account: &[u8]) -> Access; } …or as multiple standalone pro! attributes applied to the same item: Copy type Access = i32; use ink_lang as ink; #[ink::chain_extension] pub trait MyChainExtension { type ErrorCode = i32; #[ink(extension = 5)] #[ink(handle_status = false)] #[ink(returns_result = false)] fn key_access_for_account(key: &[u8], account: &[u8]) -> Access; } "},{"title":"Details: handle_status","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#details-handle_status","content":"Default value: true By default all chain extension methods return a Result<T, E> where E: From<Self::ErrorCode>. The Self::ErrorCode represents the error code of the chain extension. This means that a smart contract calling such a chain extension method first queries the returned status code of the chain extension method and only loads and decodes the output if the returned status code indicates a successful call. This design was chosen as it is more efficient when no output besides the error code is required for a chain extension call. When designing a chain extension try to utilize the error code to return errors and only use the output buffer for information that does not fit in a single u32 value. A chain extension method that is flagged with handle_status = false assumes that the returned error code will always indicate success. Therefore it will always load and decode the output buffer and loses the E: From<Self::ErrorCode constraint for the call. "},{"title":"Details: returns_result","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#details-returns_result","content":"Default value: true By default chain extension methods are assumed to return a value of type Result<T, E> through the output buffer. Using returns_result = false this check is disabled and the chain extension method may return any other type. Note that if a chain extension method is attributed with returns_result = falseand with handle_status = true it will still return a value of type Result<T, Self::ErrorCode>. "},{"title":"Usage: handle_status + returns_result","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#usage-handle_status--returns_result","content":"Use both handle_status = false and returns_result = false for the same chain extension method if a call to it may never fail and never returns a Result type. "},{"title":"Combinations","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#combinations","content":"Due to the possibility to flag a chain extension method with handle_status and returns_resultthere are 4 different cases with slightly varying semantics: handle_status\treturns_result\tEffectstrue\ttrue\tThe chain extension method is required to return a value of type Result<T, E> where E: From<Self::ErrorCode>. A call will always check if the returned status code indicates success and only then will load and decode the value in the output buffer. true\tfalse\tThe chain extension method may return any non-Result type. A call will always check if the returned status code indicates success and only then will load and decode the value in the output buffer. The actual return type of the chain extension method is still Result<T, Self::ErrorCode> when the chain extension method was defined to return a value of type T. false\ttrue\tThe chain extension method is required to return a value of type Result<T, E>. A call will always assume that the returned status code indicates success and therefore always load and decode the output buffer directly. false\tfalse\tThe chain extension method may return any non-Result type. A call will always assume that the returned status code indicates success and therefore always load and decode the output buffer directly. "},{"title":"Error Code","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#error-code","content":"Every chain extension defines exactly one ErrorCode using the following syntax: Copy use ink_lang as ink; #[ink::chain_extension] pub trait MyChainExtension { type ErrorCode = MyErrorCode; // more definitions ... } The defined ErrorCode must implement FromStatusCode which should be implemented as a more or less trivial conversion from the u32 status code to a Result<(), Self::ErrorCode>. The Ok(()) value indicates that the call to the chain extension method was successful. By convention an error code of 0 represents success. However, chain extension authors may use whatever suits their needs. "},{"title":"Example: Definition","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#example-definition","content":"In the below example a chain extension is defined that allows its users to read and write from and to the runtime storage using access privileges: Copy use ink_lang as ink; /// Custom chain extension to read to and write from the runtime. #[ink::chain_extension] pub trait RuntimeReadWrite { type ErrorCode = ReadWriteErrorCode; /// Reads from runtime storage. /// /// # Note /// /// Actually returns a value of type `Result<Vec<u8>, Self::ErrorCode>`. /// #[ink(extension = 1, returns_result = false)] /// fn read(key: &[u8]) -> Vec<u8>; /// /// Reads from runtime storage. /// /// Returns the number of bytes read and up to 32 bytes of the /// read value. Unused bytes in the output are set to 0. /// /// # Errors /// /// If the runtime storage cell stores a value that requires more than /// 32 bytes. /// /// # Note /// /// This requires `ReadWriteError` to implement `From<ReadWriteErrorCode>` /// and may potentially return any `Self::ErrorCode` through its return value. #[ink(extension = 2)] fn read_small(key: &[u8]) -> Result<(u32, [u8; 32]), ReadWriteError>; /// Writes into runtime storage. /// /// # Note /// /// Actually returns a value of type `Result<(), Self::ErrorCode>`. #[ink(extension = 3, returns_result = false)] fn write(key: &[u8], value: &[u8]); /// Returns the access allowed for the key for the caller. /// /// # Note /// /// Assumes to never fail the call and therefore always returns `Option<Access>`. #[ink(extension = 4, returns_result = false, handle_status = false)] fn access(key: &[u8]) -> Option<Access>; /// Unlocks previously aquired permission to access key. /// /// # Errors /// /// If the permission was not granted. /// /// # Note /// /// Assumes the call to never fail and therefore does _NOT_ require `UnlockAccessError` /// to implement `From<Self::ErrorCode>` as in the `read_small` method above. #[ink(extension = 5, handle_status = false)] fn unlock_access(key: &[u8], access: Access) -> Result<(), UnlockAccessError>; } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum ReadWriteErrorCode { InvalidKey, CannotWriteToKey, CannotReadFromKey, } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum ReadWriteError { ErrorCode(ReadWriteErrorCode), BufferTooSmall { required_bytes: u32 }, } impl From<ReadWriteErrorCode> for ReadWriteError { fn from(error_code: ReadWriteErrorCode) -> Self { Self::ErrorCode(error_code) } } impl From<scale::Error> for ReadWriteError { fn from(_: scale::Error) -> Self { panic!(\"encountered unexpected invalid SCALE encoding\") } } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub struct UnlockAccessError { reason: String, } impl From<scale::Error> for UnlockAccessError { fn from(_: scale::Error) -> Self { panic!(\"encountered unexpected invalid SCALE encoding\") } } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum Access { ReadWrite, ReadOnly, WriteOnly, } impl ink_env::chain_extension::FromStatusCode for ReadWriteErrorCode { fn from_status_code(status_code: u32) -> Result<(), Self> { match status_code { 0 => Ok(()), 1 => Err(Self::InvalidKey), 2 => Err(Self::CannotWriteToKey), 3 => Err(Self::CannotReadFromKey), _ => panic!(\"encountered unknown status code\"), } } } All the error types and other utility types used in the chain extension definition above are often required to implement various traits such as SCALE's Encode and Decodeas well as scale-info's TypeInfo trait. A full example of the above chain extension definition can be seenhere. "},{"title":"Example: Environment","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#example-environment","content":"In order to allow pro! smart contracts to use the above defined chain extension it needs to be integrated into an Environment definition as shown below: Copy type RuntimeReadWrite = i32; use ink_env::{Environment, DefaultEnvironment}; pub enum CustomEnvironment {} impl Environment for CustomEnvironment { const MAX_EVENT_TOPICS: usize = <DefaultEnvironment as Environment>::MAX_EVENT_TOPICS; type AccountId = <DefaultEnvironment as Environment>::AccountId; type Balance = <DefaultEnvironment as Environment>::Balance; type Hash = <DefaultEnvironment as Environment>::Hash; type BlockNumber = <DefaultEnvironment as Environment>::BlockNumber; type Timestamp = <DefaultEnvironment as Environment>::Timestamp; type ChainExtension = RuntimeReadWrite; } Above we defined the CustomEnvironment which defaults to pro!'s DefaultEnvironmentfor all constants and types but the ChainExtension type which is assigned to our newly defined chain extension. "},{"title":"Example: Usage","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#example-usage","content":"An pro! smart contract can use the above defined chain extension through the Environmentdefinition defined in the last example section using the env macro parameter as shown below. Note that chain extension methods are accessible through Self::extension() orself.extension(). For example as in Self::extension().read(..) or self.extension().read(..). Copy use ink_lang as ink; #[ink::contract(env = CustomEnvironment)] mod read_writer { use ink_lang as ink; #[ink(storage)] pub struct ReadWriter {} impl ReadWriter { #[ink(constructor)] pub fn new() -> Self { Self {} } #[ink(message)] pub fn read(&self, key: Vec<u8>) -> Result<Vec<u8>, ReadWriteErrorCode> { self.env() .extension() .read(&key) } #[ink(message)] pub fn read_small(&self, key: Vec<u8>) -> Result<(u32, [u8; 32]), ReadWriteError> { self.env() .extension() .read_small(&key) } #[ink(message)] pub fn write( &self, key: Vec<u8>, value: Vec<u8>, ) -> Result<(), ReadWriteErrorCode> { self.env() .extension() .write(&key, &value) } #[ink(message)] pub fn access(&self, key: Vec<u8>) -> Option<Access> { self.env() .extension() .access(&key) } #[ink(message)] pub fn unlock_access(&self, key: Vec<u8>, access: Access) -> Result<(), UnlockAccessError> { self.env() .extension() .unlock_access(&key, access) } } /// Custom chain extension to read to and write from the runtime. #[ink::chain_extension] pub trait RuntimeReadWrite { type ErrorCode = ReadWriteErrorCode; #[ink(extension = 1, returns_result = false)] fn read(key: &[u8]) -> Vec<u8>; #[ink(extension = 2)] fn read_small(key: &[u8]) -> Result<(u32, [u8; 32]), ReadWriteError>; #[ink(extension = 3, returns_result = false)] fn write(key: &[u8], value: &[u8]); #[ink(extension = 4, returns_result = false, handle_status = false)] fn access(key: &[u8]) -> Option<Access>; #[ink(extension = 5, handle_status = false)] fn unlock_access(key: &[u8], access: Access) -> Result<(), UnlockAccessError>; } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum ReadWriteErrorCode { InvalidKey, CannotWriteToKey, CannotReadFromKey, } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum ReadWriteError { ErrorCode(ReadWriteErrorCode), BufferTooSmall { required_bytes: u32 }, } impl From<ReadWriteErrorCode> for ReadWriteError { fn from(error_code: ReadWriteErrorCode) -> Self { Self::ErrorCode(error_code) } } impl From<scale::Error> for ReadWriteError { fn from(_: scale::Error) -> Self { panic!(\"encountered unexpected invalid SCALE encoding\") } } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub struct UnlockAccessError { reason: String, } impl From<scale::Error> for UnlockAccessError { fn from(_: scale::Error) -> Self { panic!(\"encountered unexpected invalid SCALE encoding\") } } #[derive(scale::Encode, scale::Decode, scale_info::TypeInfo)] pub enum Access { ReadWrite, ReadOnly, WriteOnly, } impl ink_env::chain_extension::FromStatusCode for ReadWriteErrorCode { fn from_status_code(status_code: u32) -> Result<(), Self> { match status_code { 0 => Ok(()), 1 => Err(Self::InvalidKey), 2 => Err(Self::CannotWriteToKey), 3 => Err(Self::CannotReadFromKey), _ => panic!(\"encountered unknown status code\"), } } } pub enum CustomEnvironment {} impl ink_env::Environment for CustomEnvironment { const MAX_EVENT_TOPICS: usize = <ink_env::DefaultEnvironment as ink_env::Environment>::MAX_EVENT_TOPICS; type AccountId = <ink_env::DefaultEnvironment as ink_env::Environment>::AccountId; type Balance = <ink_env::DefaultEnvironment as ink_env::Environment>::Balance; type Hash = <ink_env::DefaultEnvironment as ink_env::Environment>::Hash; type BlockNumber = <ink_env::DefaultEnvironment as ink_env::Environment>::BlockNumber; type Timestamp = <ink_env::DefaultEnvironment as ink_env::Environment>::Timestamp; type ChainExtension = RuntimeReadWrite; } } "},{"title":"Technical Limitations","type":1,"pageTitle":"#[ink::chain_extension]","url":"macros-attributes/chain-extension#technical-limitations","content":"Due to technical limitations it is not possible to refer to the ErrorCode associated type using Self::ErrorCode anywhere within the chain extension and its defined methods. Instead chain extension authors should directly use the error code type when required. This limitation might be lifted in future versions of pro!.It is not possible to declare other chain extension traits as super traits or super chain extensions of another. "},{"title":"#[ink(event)]","type":0,"sectionRef":"#","url":"macros-attributes/event","content":"Applicable on struct definitions. Defines an pro! event. A contract can define multiple such pro! events. See our section on Events for a detailed description and examples.","keywords":""},{"title":"#[ink(message)]","type":0,"sectionRef":"#","url":"macros-attributes/message","content":"","keywords":""},{"title":"Messages Return Value","type":1,"pageTitle":"#[ink(message)]","url":"macros-attributes/message#messages-return-value","content":"The return value of a message needs to implement scale::Encode. It is notable that the collections under ink_storage ‒ such as e.g. Vec or HashMap ‒ don't implement scale::Encode. This means you can't just return a Vec from an pro! message. This restriction is intentional ‒ returning a complete data structure with a potentially unbounded content is an anti-pattern for smart contracts. Just think about the unpredicatble gas costs. If you really really need to return a data structure in its entirety then use the ones fromink_prelude (e.g. ink_prelude::vec::Vec). Those implement scale::Encode. "},{"title":"Example","type":1,"pageTitle":"#[ink(message)]","url":"macros-attributes/message#example","content":"Given the Flipper contract definition above we add some #[ink(message)] definitions as follows: Copy use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn new(initial_value: bool) -> Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] pub fn flip(&mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message)] pub fn get(&self) -> bool { self.value } } } "},{"title":"#[ink(namespace = \"…\")]","type":0,"sectionRef":"#","url":"macros-attributes/namespace","content":"","keywords":""},{"title":"Example","type":1,"pageTitle":"#[ink(namespace = \"…\")]","url":"macros-attributes/namespace#example","content":"Copy #[ink(namespace = \"my_namespace\")] impl MyTrait for MyStorage { #[ink(message)] fn my_message(&self) {} } This changes the resulting selectors of all the pro! messages and pro! constructors within the trait implementation. Thus allowing disambiguation between trait implementations with overlapping message or constructor names. "},{"title":"#[ink(impl)]","type":0,"sectionRef":"#","url":"macros-attributes/impl","content":"","keywords":""},{"title":"Example","type":1,"pageTitle":"#[ink(impl)]","url":"macros-attributes/impl#example","content":"An implementation block can be defined as a trait implementation for the pro! storage struct using the #[ink(impl)] annotation ‒ even if none of its interior items have any pro! specific attributes on them: Copy use core::convert::TryFrom; use ink_lang_ir as ir; #[ink::contract] mod my_module { #[ink(storage)] pub struct MyStorage { /* storage fields */ } #[ink(impl)] impl MyStorage { fn my_method(&self) -> i32 { /* method implementation */ } } impl MyStorage { #[ink(constructor)] pub fn my_constructor() -> Self { /* constructor implementation */ } #[ink(message)] pub fn my_message(&self) { /* message implementation */ } } } "},{"title":"#[ink(payable)]","type":0,"sectionRef":"#","url":"macros-attributes/payable","content":"","keywords":""},{"title":"Example","type":1,"pageTitle":"#[ink(payable)]","url":"macros-attributes/payable#example","content":"Copy #[ink(message, payable)] pub fn pay_me(&self) { let _transferred = self.env().transferred_balance(); } See the examples/contract-transfer contract for a more extensive example. "},{"title":"#[ink(selector = \"…\")]","type":0,"sectionRef":"#","url":"macros-attributes/selector","content":"","keywords":""},{"title":"Examples","type":1,"pageTitle":"#[ink(selector = \"…\")]","url":"macros-attributes/selector#examples","content":"Copy impl MyStorage { #[ink(message, selector = \"0xDEADBEEF\")] fn my_message(&self) {} } … then the selector of my_message is simply 0xDEADBEEF since it overrides the composed selector. "},{"title":"Controlling the messages selector","type":1,"pageTitle":"#[ink(selector = \"…\")]","url":"macros-attributes/selector#controlling-the-messages-selector","content":"Every pro! message and pro! constructor has a unique selector with which the message or constructor can be uniquely identified within the pro! smart contract. These selectors are mainly used to drive the contract's dispatch upon calling it. An pro! smart contract author can control the selector of an pro! message or pro! constructor using the selector flag. An example is shown below: Copy use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] #[ink(selector = \"0xDEADBEEF\")] // Works on constructors as well. pub fn new(initial_value: bool) -> Self { Flipper { value: false } } /// Flips the current value. #[ink(message)] #[ink(selector = \"0xCAFEBABE\")] // You can either specify selector out-of-line. pub fn flip(&mut self) { self.value = !self.value; } /// Returns the current value. #[ink(message, selector = \"0xFEEDBEEF\")] // or specify selector inline. pub fn get(&self) -> bool { self.value } } } "},{"title":"#[ink(storage)]","type":0,"sectionRef":"#","url":"macros-attributes/storage","content":"","keywords":""},{"title":"Example","type":1,"pageTitle":"#[ink(storage)]","url":"macros-attributes/storage#example","content":"Copy use ink_lang as ink; #[ink::contract] mod flipper { #[ink(storage)] pub struct Flipper { value: bool, } impl Flipper { #[ink(constructor)] pub fn construct() -> Self { Flipper { value: false } } #[ink(message)] pub fn message(&self) {} } } "},{"title":"#[ink(topic)]","type":0,"sectionRef":"#","url":"macros-attributes/topic","content":"","keywords":""},{"title":"Example","type":1,"pageTitle":"#[ink(topic)]","url":"macros-attributes/topic#example","content":"Copy #[ink(event)] pub struct Transferred { #[ink(topic)] from: Option<AccountId>, #[ink(topic)] to: Option<AccountId>, amount: Balance } "},{"title":"Why Rust for Smart Contracts?","type":0,"sectionRef":"#","url":"why-rust-for-smart-contracts","content":"pro! chooses not to invent a new programming language, but rather adapt a subset of Rust to serve our purpose. If this doesn't already convince you, you find many more good reasons here: Rust is an ideal smart contract language: It is type safe, memory safe, and free of undefined behaviors. It generates small binaries because it doesn’t include extra bloat, like a garbage collector, and advanced optimizations and tree shaking remove dead code. Through compiler flags, Rust can automatically protect against integer overflow.Rust ecosystem: You gain from all of support available to the Rust ecosystem for free. As the language develops, pro! will automatically gain access to new features and functionality, improving how you can write smart contracts in the future.Tooling: Because pro! follows Rust standards, tools like rustfmt, clippy and rust-analyzer already work out of the box. Same goes for code formatting and syntax highlighting in most modern text editors. Also Rust has an integrated test and benchmark runner,No overhead: Minimal runtime.Safe & Efficient: Zero-cost & safe abstractions.Productive: Cargo + crates.io Ecosystem.1st class Wasm: Rust provides the first class support for the WebAssembly.Small Size: In the space-constrained blockchain world size is important. The Rust compiler is a great help for that, since it reorders struct fields in order to make each type as small as possible. Thus Rust data structures are very compact, in many cases even more compact than in C.","keywords":""},{"title":"Why WebAssembly for Smart Contracts?","type":0,"sectionRef":"#","url":"why-webassembly-for-smart-contracts","content":"High performance: Wasm is high performance — it’s built to be as close to native machine code as possible while still being platform independent.Small size It facilitates small binaries to ship over the internet to devices with potentially slow internet connection. This is a great fit for the space-constrainted blockchain world.General VM & bytecode:It was developed so that code can be deployed in any browser with the same result. Contrary to the EVM it was not developed towards a very specific use case, this has the benefit of a lot of tooling being available and large companies putting a lot of resources into furthering Wasm development.Efficient JIT execution:64 and 32-bit integer operation support that maps one-to-one with CPU instructions.Minimalistic Formal spec that fits on a single pageDeterministic execution:Wasm is easily made deterministic by removing floating point operations, which is necessary for consensus algorithms.Open Standards > Custom Solutions:Wasm is a standard for web browsers developed by W3C workgroup that includes Google, Mozilla, and others. There’s been many years of work put into Wasm, both by compiler and standardisation teams.Many languages available: Wasm expands the family of languages available to smart contract developers to include Rust, C/C++, C#, Typescript, Haxe, and Kotlin. This means you can write smart contracts in whichever language you’re familiar with, though we’re partial to Rust due to its lack of runtime overhead and inherent security properties.Memory-safe, sandboxed, and platform-independent.LLVM supportSupported by the LLVM compiler infrastructure project, meaning that Wasm benefits from over a decade of LLVM’s compiler optimisation.Large companies involved: Continually developed by major companies such as Google, Apple, Microsoft, Mozilla, and Facebook.","keywords":""}]