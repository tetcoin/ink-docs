(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{110:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),u=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(n),b=a,d=p["".concat(s,".").concat(b)]||p[b]||m[b]||i;return n?r.a.createElement(d,o(o({ref:t},l),{},{components:n})):r.a.createElement(d,o({ref:t},l))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=b;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var l=2;l<i;l++)s[l]=n[l];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},64:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));var a=n(2),r=n(6),i=(n(0),n(110)),s={title:"#[ink(message)]",slug:"/macros-attributes/message"},o={unversionedId:"macros-attributes/message",id:"macros-attributes/message",isDocsHomePage:!1,title:"#[ink(message)]",description:"Applicable to methods.",source:"@site/docs/macros-attributes/message.md",slug:"/macros-attributes/message",permalink:"/pro-docs/macros-attributes/message",editUrl:"https://github.com/pro-docs/edit/master/docs/macros-attributes/message.md",version:"current",sidebar:"reference",previous:{title:"#[ink(impl)]",permalink:"/pro-docs/macros-attributes/impl"},next:{title:'#[ink(namespace = "\u2026")]',permalink:"/pro-docs/macros-attributes/namespace"}},c=[{value:"Messages Return Value",id:"messages-return-value",children:[]},{value:"Example",id:"example",children:[]}],l={rightToc:c};function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Applicable to methods."),Object(i.b)("p",null,"Flags a method for the pro! storage struct as message making it available to the API for calling the contract. "),Object(i.b)("p",null,"Note that all public functions must use the ",Object(i.b)("inlineCode",{parentName:"p"},"#[ink(message)]")," attribute"),Object(i.b)("p",null,"There must be at least one ",Object(i.b)("inlineCode",{parentName:"p"},"#[ink(message)]")," defined method."),Object(i.b)("p",null,"Methods flagged with ",Object(i.b)("inlineCode",{parentName:"p"},"#[ink(message)]")," are special in that they are dispatchable\nupon contract invocation. The set of pro! messages defined for an pro! smart contract\ndefine its API surface with which users are allowed to interact."),Object(i.b)("p",null,"An pro! smart contract can have multiple such pro! messages defined."),Object(i.b)("p",null,"An pro! message with a ",Object(i.b)("inlineCode",{parentName:"p"},"&self")," receiver may only read state whereas an pro! message\nwith a ",Object(i.b)("inlineCode",{parentName:"p"},"&mut self")," receiver may mutate the contract's storage."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"#[ink(message)]\npub fn purely_reading(&self, from: AccountId) {\n    // actual implementation\n}\n\n#[ink(message)]\npub fn mutates_storage(&mut self, from: AccountId) {\n    // actual implementation\n}\n")),Object(i.b)("h2",{id:"messages-return-value"},"Messages Return Value"),Object(i.b)("p",null,"The return value of a message needs to implement ",Object(i.b)("inlineCode",{parentName:"p"},"scale::Encode"),"."),Object(i.b)("p",null,"It is notable that the collections under ",Object(i.b)("inlineCode",{parentName:"p"},"ink_storage")," \u2012 such as e.g. ",Object(i.b)("inlineCode",{parentName:"p"},"Vec")," or ",Object(i.b)("inlineCode",{parentName:"p"},"HashMap")," \u2012\ndon't implement ",Object(i.b)("inlineCode",{parentName:"p"},"scale::Encode"),". This means you can't just return a ",Object(i.b)("inlineCode",{parentName:"p"},"Vec")," from an pro! message.\nThis restriction is intentional \u2012 returning a complete data structure with a potentially unbounded\ncontent is an anti-pattern for smart contracts. Just think about the unpredicatble gas costs."),Object(i.b)("p",null,"If you ",Object(i.b)("em",{parentName:"p"},"really really")," need to return a data structure in its entirety then use the ones from\n",Object(i.b)("inlineCode",{parentName:"p"},"ink_prelude")," (e.g. ",Object(i.b)("inlineCode",{parentName:"p"},"ink_prelude::vec::Vec"),"). Those implement ",Object(i.b)("inlineCode",{parentName:"p"},"scale::Encode"),"."),Object(i.b)("h2",{id:"example"},"Example"),Object(i.b)("p",null,"Given the ",Object(i.b)("inlineCode",{parentName:"p"},"Flipper")," contract definition above we add some ",Object(i.b)("inlineCode",{parentName:"p"},"#[ink(message)]")," definitions\nas follows:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"use ink_lang as ink;\n\n#[ink::contract]\nmod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n\n        #[ink(constructor)]\n        pub fn new(initial_value: bool) -> Self {\n            Flipper { value: false }\n        }\n\n        /// Flips the current value.\n        #[ink(message)]\n        pub fn flip(&mut self) {\n            self.value = !self.value;\n        }\n\n        /// Returns the current value.\n        #[ink(message)]\n        pub fn get(&self) -> bool {\n            self.value\n        }\n    }\n}\n")))}u.isMDXComponent=!0}}]);